=================
Command framework
=================

Squirtgun includes a flexible command framework, taking design cues from Mojang's Brigadier. It aims to be declarative wherever possible to make creating complex command chains easy.

This page is still a work-in-progress, and is intended to be used alongside the ``squirtgun-commands`` Javadoc, available at https://javadoc.lucyy.me.

#########
Key Terms
#########

+++++++
Command
+++++++
There is no such thing as a command.

+++++++++++++
Command Chain
+++++++++++++
* A command chain is a list of command nodes.
* Whereas a framework designed by someone with an element of sanity might use a tree, the command chain is entirely implicit and is generated by the context.

++++++++++++
Command Node
++++++++++++
* A command node is a single element in a command, that does a thing when executed.
* It may expose arguments. 
* It may have a child node - when this is used is explained below.
* Command nodes can not be tab-completed, however its arguments can.

++++++++
Argument
++++++++
* An argument is some kind of value that a command node expects input for.
* It is *not* necessarily a single space-delimited string element as most low-level frameworks such as Bukkit provide.
* An argument can be tab-completed.

+++++++++++++++
Command Context
+++++++++++++++
* A command context holds information regarding the command sender and arguments provided so far.
* The context object is responsible for executing and tab-completing the command.
* A context object should be used to parse a command once and then disposed of.


++++++
Target
++++++
* The target is the entity that the command came from. In its current form, it must extend PermissionHolder.
* Player targets can implement SquirtgunPlayer.

######################
Building command nodes
######################

All command chains built with the framework start life as a node. There are two ways to construct a node:

+++++++++++++++++++++++++++
Implementing CommandNode<T>
+++++++++++++++++++++++++++

For longer commands, implementing CommandNode<T> helps to separate out the code into several files.
::

        public class ExampleNode implements CommandNode<PermissionHolder> {
                
                @Override
                public @NotNull String getName() {
                        return "example";
                }

                @Override
                public String getDescription() {
                        return "Does the example thing.";
                }

                @Override
                public Component execute(CommandContext<PermissionHolder> context) {
                        return context.getFormat().getPrefix()
                                .append(context.getFormat().formatMain("Hello world!");
                }

        }

+++++++++++++++++
Using the builder
+++++++++++++++++

The builder can be used for shorter commands, and accepts a function to execute the command.
::

        final CommandNode<PermissionHolder> node = new NodeBuilder<>()
                .name("example")
                .description("Does the example thing.")
                .executes(context -> context.getFormat().getPrefix()
                        .append(context.getFormat().formatMain("Hello world!")))
                .build();

###############
Formatting text
###############

The framework is quite heavily built adounr Kyori's Adventure formatting library. You might have noticed that execute methods return a Component. This component is optional, and will be sent back to the executor if present.

To help give commands a consistent look, the context is capable of providing a FormatProvider. It's recommended to use this instead of accessing the format provider directly. See the formatting page for more information. 

###############
Executing nodes
###############

How you actually use the node you've constructed depends on the platform you're targeting.

++++++
Bukkit
++++++

The ``squirtgun-bukkit`` artifact contains a class ``BukkitNodeExecutor`` that handles execution for you::

        final TabExecutor executor = new BukkitNodeExecutor(yourRootNode, yourFormatProvider);
	final PluginCommand cmd = getCommand("commandName");
	Objects.requireNonNull(cmd);
	cmd.setExecutor(executor);
	cmd.setTabCompleter(executor);

+++++++++++++++++++++++
Manual context creation
+++++++++++++++++++++++

This method should be used when a platform-specific executor is not available. It requires that a ``PermissionHolder`` implementation is available for your platform::

        CommandContext<PermissionHolder> context = new StringContext<>(
                formatProvider,
                target,
                rootNode,
                argumentsAsString);

        // to execute
        @Nullable Component executed = context.execute();

        // to tab-complete
        @Nullable List<String> tabCompleted = context.tabComplete()

StringContext is currently the only CommandContext implementation available. 

#########
Arguments
#########

A command node can have several arguments. An argument corresponds to something specified in the command string.

Before a command is executed, the context will parse the input that it's been given. If an argument is missing and it is *not* declared as optional, then the command will not be executed and the context will return an error message. If it is optional then it will have a null value.

It's very important that arguments are **not** static fields - if two instances of the same node type are in the command chain then the same argument instance will appear twice, which is prohibited and will cause strange behaviour.

An example of using arguments::

        public class ExampleNodeWithArguments implements CommandNode<PermissionHolder> {
                private final CommandArgument<String> arg1 = new SingleWordArgument(
                        "argName",
                        "argument description",
                        false);

                private final CommandArgument<SquirtgunPlayer> playerArg = new OnlinePlayerArgument(
                        "player",
                        "The player to do the thing for",
                        true, // this one's optional
                        aPlatformInstance);

                @Override
                public @NotNull List<CommandArgument<?>> getArguments() {
                        return List.of(arg1, playerArg);
                }
                
                // other methods omitted for the sake of brevity
        }

There are several available types of prewritten arguments - see the classes in the ``me.lucyy.squirtgun.command.node`` package.

++++++++++++++++++++++++++
Writing your own arguments
++++++++++++++++++++++++++

Creating your own arguments to parse values from strings is very straightforward. Here's an example, namely the builtin ``OnlinePlayerArgument``::
        
        /**
        * An argument that gets a player. This will tabcomplete for online players, but will
        * provide any player, regardless of if they are online or not.
        */
        public class OnlinePlayerArgument extends AbstractArgument<SquirtgunPlayer> {
                private final Platform platform;

                public OnlinePlayerArgument(String name, String description, boolean isOptional, Platform platform) {
                        super(name, description, isOptional);
                        this.platform = platform;
                }

                @Override
                public SquirtgunPlayer getValue(Queue<String> args) {
                        String name = args.poll();
                        return name == null || "".equals(name) ? null : platform.getPlayer(name);
                }

                @Override
                public @Nullable List<String> tabComplete(Queue<String> args) {
                        String name = args.poll();
                        return name == null ? null : platform.getOnlinePlayers()
                                        .stream()
                                        .map(SquirtgunPlayer::getUsername)
                                        .filter(username -> username.startsWith(name))
                                        .collect(Collectors.toList());
                }
        }

The Queue<String> provided is a queue of the string elements of the command. When implementing an argument, you should only pop the values that you read as part of the argument.

##############
Chaining nodes
##############

Having a single node in a command chain is all well and good, but it's not very flexible. This is where node chaining comes in.

+++++++++++++++++
Manually chaining
+++++++++++++++++

``CommandNode`` exposes a method ``@Nullable CommandNode<T> next(CommandContext<T>)``, which can be used to specify the next node in the chain. It's intended to be dynamic, and may return different values depending on argument values, etc. It has a default implementation where it will return null, indicating that there are no further nodes in the chain.

After the node's arguments are processed, the context will check if the next node is null. If it is, then the current node will be executed, otherwise the same check will occur for the next node recursively. This means that if ``next()`` never returns null, then the node's ``execute()`` method will **never** be called.

++++++++++++++++++++
Using SubcommandNode
++++++++++++++++++++

``SubcommandNode`` does exactly what it says on the tin - it allows breaking a command chain into several subcommands. It also shows help if the command is invalid.


########
Examples
########

If you prefer to learn by example, have a look at ProNouns (https://github.com/lucyy-mc/ProNouns). 
